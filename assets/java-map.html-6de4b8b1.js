import{_ as a,W as e,X as d,a2 as t}from"./framework-3c1374b9.js";const h={},r=t('<h1 id="map基础-详解" tabindex="-1"><a class="header-anchor" href="#map基础-详解" aria-hidden="true">#</a> Map基础 - 详解</h1><h2 id="map-接口概览" tabindex="-1"><a class="header-anchor" href="#map-接口概览" aria-hidden="true">#</a> Map 接口概览</h2><p>Map接口主要存放键值对。从顺序上可以分为有序Map和无序Map，从安全性上可以分为线程安全Map和非线程安全Map。</p><h2 id="无序map和有序map" tabindex="-1"><a class="header-anchor" href="#无序map和有序map" aria-hidden="true">#</a> 无序Map和有序Map</h2><ul><li>无序Map：<code>HashMap</code>，<code>HashTable</code>，<code>ConcurrentHashMap</code>,<code>ThreadLocalMap</code></li><li>有序Map：<code>TreeMap</code>，<code>LinkedHashMap</code>，<code>ConcurrentSkipListMap</code></li></ul><h2 id="线程安全map和线程不安全map" tabindex="-1"><a class="header-anchor" href="#线程安全map和线程不安全map" aria-hidden="true">#</a> 线程安全Map和线程不安全Map</h2><ul><li>线程安全Map：<code>HashTable</code>，<code>ConcurrentHashMap</code>，<code>ConcurrentSkipListMap</code></li><li>线程不安全Map：<code>HashMaap</code>，<code>TreeMap</code>，<code>ThreadLocalMap</code>，<code>LinkedHashMap</code></li></ul><h2 id="实现map接口有哪些类" tabindex="-1"><a class="header-anchor" href="#实现map接口有哪些类" aria-hidden="true">#</a> 实现Map接口有哪些类？</h2><table><thead><tr><th>类</th><th>线程安全</th><th>有序性</th><th>底层数据结构</th><th>初始容量</th><th>负载因子</th><th>实例化方式</th></tr></thead><tbody><tr><td>HashMap</td><td>不安全</td><td>无序</td><td>数组+链表+红黑树</td><td>16</td><td>0.75</td><td>懒加载</td></tr><tr><td>HashTable</td><td>安全</td><td>无序</td><td>数组+链表</td><td>11</td><td>0.75</td><td>初始化创建</td></tr><tr><td>ThreadLocalMap</td><td>不安全</td><td>无序</td><td>数组</td><td>16</td><td>0.75</td><td>懒创建</td></tr><tr><td>TreeMap</td><td>不安全</td><td>有序(左小右大)</td><td>红黑树</td><td>-</td><td>-</td><td>-</td></tr><tr><td>LinkedHashMap</td><td>不安全</td><td>有序(插入顺序)</td><td>数组+单双向链表</td><td>-</td><td>-</td><td>-</td></tr><tr><td>ConcurrentHashMap</td><td>安全</td><td>无序</td><td>数组+链表+红黑树</td><td>16</td><td>0.75</td><td>懒加载</td></tr><tr><td>ConcurrentSkipListMap</td><td>安全</td><td>有序(左小右大)</td><td>跳跃表</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable的区别" aria-hidden="true">#</a> HashMap和HashTable的区别</h2><ul><li><code>线程安全</code>：HashMap线程不安全，HashTable线程安全。</li><li><code>效率</code>：因为HashTable内部使用了<strong>synchornized</strong>关键字进行同步，所以效率低于HashMap。（HashTable基本被淘汰，如果要使用线程安全Map推荐使用ConcurrentHashMap）</li><li><code>有序性</code>：HashMap和HashTable都无序。</li><li><code>Null的支持</code>：HashMap允许Null的键值对，只能有一个Null的Key，但是允许有多个Null的Value。HashTable不允许有Null键值对。</li><li><code>初始化</code>：HashMap默认初始化大小为16，HashTable默认初始化大小为11。</li></ul><h2 id="hashmap和treemap-区别·" tabindex="-1"><a class="header-anchor" href="#hashmap和treemap-区别·" aria-hidden="true">#</a> HashMap和TreeMap 区别·</h2><ul><li><code>有序性</code>：<strong>HashMap无序，TreeMap有序</strong>。HashMap是通过hash值进行快速查找的；HashMap中的元素是没有顺序的；TreeMap中所有的元素都是以自然顺序（升序）排序，如果需要得到一个有序的结果，就应该使用TreeMap</li><li><code>线程安全</code>：<strong>HashMap和TreeMap线程都不安全</strong>。</li><li><code>效率</code>：hashMap底层是数组，在添加查找删除等方面速度比较快。TreeMap底层是Tree接口，速度比较慢。但是HashMap要保存一个Array，会造成空间浪费，而TreeMap只保存要保留的节点，占用空间较小。</li><li><code>Null的支持</code>：HashMap允许Null的键值对，只能有一个Null的Key，但是允许有多个Null的Value。TreeMap不允许有Null的Key但是允许有多个Null的Value</li><li><code>比较键</code>：HashMap使用Object类的equals()方法比较键。 Map类的equals()方法将其覆盖。HashTable使用compareTo()方法比较键。</li></ul><h2 id="hashmap与concurrenthashmap-的区别是什么" tabindex="-1"><a class="header-anchor" href="#hashmap与concurrenthashmap-的区别是什么" aria-hidden="true">#</a> HashMap与ConcurrentHashMap 的区别是什么</h2><ul><li><code>线程安全</code>：HashMap线程不安全，ConcurrentHashMap线程安全</li></ul><h2 id="concurrenthashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap和hashtable的区别" aria-hidden="true">#</a> ConcurrentHashMap和HashTable的区别</h2><ul><li><code>底层数据结构</code>：JDK1.8采用的数据结构和JDK1.8的HashMap结构一样，都是<strong>数组+链表+红黑树</strong>。HashTable和JDK1.8之前的HashMap的底层数据结构类似，都是<strong>数组+链表</strong>。链表是为了解决哈希冲突的问题。</li><li><code>实现线程安全的方式</code>： <ul><li>JDK1.7时，ConcurrentHashMap对整个哈希桶进行分段切割。每一段都有一把锁，多线程访问容器里不同的数据段数据的时候，就不会存在竞争，提高了并发访问率。</li><li>JDK1.8之后ConcurrentHashMap撅弃了分段锁的概念。直接使用<strong>数组+链表+红黑树</strong>的数据结构实现。并发控制使用synchronized和CAS来操作。</li><li>HashTable使用的是同一把锁，使用synchronized来保证线程安全，效率比较低下，当一个线程put元素的时候，其他线程不能put，高并发下竞争激烈，不推荐使用。</li></ul></li></ul><h2 id="jdk1-7和jdk1-8concurrenthashmap有什么不同" tabindex="-1"><a class="header-anchor" href="#jdk1-7和jdk1-8concurrenthashmap有什么不同" aria-hidden="true">#</a> JDK1.7和JDK1.8ConcurrentHashMap有什么不同</h2><ul><li><code>实现线程安全的方式</code>：1.7的ConcurrentHashMap底层使用<strong>分段数组+链表</strong>实现，JDK1.8采用的数据结构和JDK1.8的HashMap结构一样，都是<strong>数组+链表+红黑树</strong></li><li><code>并发度</code>：1.7之前的最大并发数为分段锁的数量(16)，1.8之后最大并发数为Node数组的大小，并发数更大</li><li><code>Hash冲突解决方案</code>：1.7采用拉链法，1.8采用拉链法+红黑树（链表和数组长度超过一定阈值后将链表转为红黑树）</li></ul><h2 id="hashmap长度为什么是2的幂" tabindex="-1"><a class="header-anchor" href="#hashmap长度为什么是2的幂" aria-hidden="true">#</a> HashMap长度为什么是2的幂</h2><ul><li>HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布</li><li>扩容迁移的时候不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原脚标位+扩容长度这么一个位置</li></ul><h2 id="hashmap-的-get-方法能否判断某个元素是否在-map-中" tabindex="-1"><a class="header-anchor" href="#hashmap-的-get-方法能否判断某个元素是否在-map-中" aria-hidden="true">#</a> HashMap 的 get 方法能否判断某个元素是否在 map 中</h2><p><code>不可以</code>，因为HashMap的Key和Value都可以为null，使用get方法并不能确定是真正意义上的null还是此元素就是null。如果要判断某个元素是否在map中，应该使用<code>containsKey</code></p><h2 id="linkedhashmap-的实现原理" tabindex="-1"><a class="header-anchor" href="#linkedhashmap-的实现原理" aria-hidden="true">#</a> LinkedHashMap 的实现原理</h2><p>LinkedHashMap继承hashMap，可以理解为HashMap的增强体。HashMap因为底层数据结构，导致了她的无序性， LinkedHashMap使用了一对双向链表来记录添加元素的顺序。 LinkedHashMap的put存放元素其实是调用的HashMap的put方法。LinkedHashMap的重写了get()方法</p>',25),s=[r];function l(p,c){return e(),d("div",null,s)}const i=a(h,[["render",l],["__file","java-map.html.vue"]]);export{i as default};
